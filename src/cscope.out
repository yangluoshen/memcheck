cscope 15 /home/yangluo/github/memcheck/src -q 0000000127 0000006750
	@loghandle.cpp

1 
	~<f¡»am
>

2 
	~<s¡»am
>

3 
	~<ùime
>

4 
	~<¡ršg
>

6 
	sLogH—dInfo


8 
size_t
 
	mËak_sum
;

9 
	m¡d
::
¡ršg
 
desütiÚ
;

12 þas 
	cLogHªdË


14 
	m´iv©e
:

15 
¡d
::
¡ršg
 
log_fže_Çme
;

16 
	elog_Ëv–


18 
	mLOG_INFO
,

19 
	mLOG_DEBUG
,

20 
	mLOG_ERROR
,

21 
	mLOG_CRITICAL
,

22 
	mLOG_BUTT


26 
	gpublic
:

27 
LogHªdË
& 
g‘_š¡ªû
();

28 
log_debug
(cÚ¡ 
¡d
::
¡ršg
& 
cÚ‹Á
);

29 
log_”rÜ
(cÚ¡ 
¡d
::
¡ršg
& 
cÚ‹Á
);

30 
log_h—d_šfo
(
LogH—dInfo
 
h—d_šfo
);

31 
log_´št
(cÚ¡ 
¡d
::
¡ršg
& 
log
);

33 
	g´iv©e
:

34 
	$LogHªdË
(){
	}
};

35 
	gvœtu®
 ~
	$LogHªdË
(){
	}
};

36 
log_cÚsi¡
(
log_Ëv–
 
Ëv–
, cÚ¡ 
¡d
::
¡ršg
& 
cÚ‹Á
, std::¡ršg& 
log
);

37 
g‘_logÇme
(
¡d
::
¡ršg
& 
log_Çme
);

38 
g‘_sy¡ime
(
¡d
::
¡ršg
& 
now
);

42 
	gLogHªdË
& LogHªdË::
	$g‘_š¡ªû
()

44 
LogHªdË
 
s_š¡ªû
;

45  
s_š¡ªû
;

46 
	}
}

48 
	gLogHªdË
::
	$log_cÚsi¡
(
log_Ëv–
 
Ëv–
, cÚ¡ 
¡d
::
¡ršg
& 
cÚ‹Á
, std::¡ršg& 
log
)

50 ()
	`g‘_sy¡ime
(
log
);

51 
Ëv–
)

53 
LOG_INFO
:

54 
log
.
	`­³nd
(":[I] ");

56 
LOG_DEBUG
:

57 
log
.
	`­³nd
(":[D] ");

59 
LOG_ERROR
:

60 
log
.
	`­³nd
(":[E] ");

66 
log
.
	`­³nd
(
cÚ‹Á
);

69 
	}
}

71 
	gLogHªdË
::
	$log_´št
(cÚ¡ 
¡d
::
¡ršg
& 
log
)

73 ià(
log_fže_Çme
.
	`em±y
())

75 
	`g‘_logÇme
(
this
->
log_fže_Çme
);

78 
¡d
::
of¡»am
 
	`fout
(
this
->
log_fže_Çme
.
	`c_¡r
(), std::of¡»am::
out
 | std::of¡»am::
­p
);

79 ià(!
fout
.
	`is_Ý’
())

84 
¡d
::
¡ršg
 
	`log_buf
(
log
);

85 
log_buf
.
	`­³nd
("\r\n");

87 
fout
.
	`wr™e
(
log_buf
.
	`c_¡r
(),†og_buf.
	`size
());

89 
fout
.
	`þo£
();

91 
	}
}

93 
	gLogHªdË
::
	$log_debug
(cÚ¡ 
¡d
::
¡ršg
& 
cÚ‹Á
)

95 
¡d
::
¡ršg
 
log
;

96 
	`log_cÚsi¡
(
LOG_DEBUG
, 
cÚ‹Á
, 
log
);

97 
	`log_´št
(
log
);

98 
	}
}

100 
	gLogHªdË
::
	$log_”rÜ
(cÚ¡ 
¡d
::
¡ršg
& 
cÚ‹Á
)

102 
¡d
::
¡ršg
 
log
;

103 
	`log_cÚsi¡
(
LOG_ERROR
, 
cÚ‹Á
, 
log
);

104 
	`log_´št
(
log
);

106 
	}
}

108 
	gLogHªdË
::
	$g‘_logÇme
(
¡d
::
¡ršg
& 
log_Çme
)

110 
pid_t
 
pid
 = 
	`g‘pid
();

111 
¡d
::
o¡ršg¡»am
 
	`os
("");

112 
os
 << 
pid
;

113 
os
 << ".log";

115 
log_Çme
.
	`­³nd
("/tmp/fizz.memcheck.");

116 
log_Çme
.
	`­³nd
(
os
.
	`¡r
());

118 
	}
}

120 
	gLogHªdË
::
	$g‘_sy¡ime
(
¡d
::
¡ršg
& 
now
)

122 
time_t
 
now_time
;

123 
now_time
 = 
	`time
(
NULL
);

124 
time_buf
[20] = {0};

125 
	`¡ráime
(
time_buf
,  (time_buf), "%H:%M:%S", 
	`loÿÉime
(&
now_time
));

127 
now
.
	`assign
(
time_buf
);

129 
	}
}

131 
	gLogHªdË
::
	$log_h—d_šfo
(
LogH—dInfo
 
h—d_šfo
)

133 
¡d
::
¡ršg
 
	`ouut
("/**************************\n");

134 
ouut
.
	`­³nd
("*†eak‚um: ");

136 
¡d
::
o¡ršg¡»am
 
	`num_of_Ëak
("");

137 
num_of_Ëak
 << 
h—d_šfo
.
Ëak_sum
;

138 
ouut
.
	`­³nd
(
num_of_Ëak
.
	`¡r
());

140 
ouut
.
	`­³nd
("\n************************/\n\n");

142 
	`log_´št
(
ouut
);

143 
	}
}

	@mempool.cpp

1 
	~<m®loc.h
>

2 
	~<¡dlib.h
>

4 
	~<¡ršg
>

5 
	~<m­
>

6 
	~<veùÜ
>

8 
	~"loghªdË.ýp
"

9 
	~"memutž.ýp
"

11 cÚ¡ 
size_t
 
	gMAX_LEAK_RECORD_NUM
 = 1000;

13 
	sAddrInfo


15 
	m¡d
::
¡ršg
 
fže_Çme
;

16 
	m¡d
::
¡ršg
 
lše_no
;

17 
	m¡d
::
¡ršg
 
func_Çme
;

18 
	m¡d
::
veùÜ
<
¡d
::
¡ršg
> 
vec_backŒaû
;

19 * 
	maddr
;

22 
	g¡d
::
m­
<*, 
	gAddrInfo
> 
	gg_m­_memÜy_addr
;

25 
g‘_ÿÎ”_func
(
¡d
::
veùÜ
<¡d::
¡ršg
>& 
vec_backŒaû
, std::¡ršg& 
ÿÎ”_Çme
);

27 (*
Þd_ä“
)(*
±r
, cÚ¡ *
ÿÎ”
);

28 *(*
Þd_m®loc
)(
size_t
 
size
, cÚ¡ *
ÿÎ”
);

30 
	`__fizz_ä“
(*
±r
, cÚ¡ *
ÿÎ”
);

31 *
	`__fizz_m®loc
(
size_t
 
size
, cÚ¡ *
ÿÎ”
);

33 
	$__fizz_hook_back
()

35 
Þd_m®loc
 = 
__m®loc_hook
;

36 
Þd_ä“
 = 
__ä“_hook
;

37 
	}
}

39 
	$__fizz_hook_š™
()

41 
__m®loc_hook
 = 
__fizz_m®loc
;

42 
__ä“_hook
 = 
__fizz_ä“
;

43 
	}
}

45 
	$__fizz_hook_»¡Üe
()

47 
__m®loc_hook
 = 
Þd_m®loc
;

48 
__ä“_hook
 = 
Þd_ä“
;

49 
	}
}

51 
	$__fizz_ä“
(*
±r
, cÚ¡ *
ÿÎ”
) {

52 
	`__fizz_hook_»¡Üe
();

54 #ià
defšed
 
__MEMPOOL_RUNTIME_DETAIL


58 
¡d
::
m­
<*, 
AddrInfo
>::
™”©Ü
 
™”
 = 
g_m­_memÜy_addr
.
	`fšd
(
±r
);

59 ià(
™”
 !ð
g_m­_memÜy_addr
.
	`’d
())

61 
g_m­_memÜy_addr
.
	`”a£
(
±r
);

65 
	`ä“
(
±r
);

66 (è
ÿÎ”
;

67 
	`__fizz_hook_š™
();

69 
	}
}

71 *
	$__fizz_m®loc
(
size_t
 
size
, cÚ¡ *
ÿÎ”
)

73 *
±r
 = 
NULL
;

74 
	`__fizz_hook_»¡Üe
();

75 
±r
 = 
	`m®loc
(
size
);

76 #ià
defšed
 
__MEMPOOL_RUNTIME_DETAIL


78 ià(
±r
)

80 
¡d
::
¡ršg
 
ÿÎ”_Çme
;

81 
AddrInfo
 
addrInfo
;

82 
addrInfo
.
addr
 = 
±r
;

83 (è
	`g‘_ÿÎ”_func
(
addrInfo
.
vec_backŒaû
, 
ÿÎ”_Çme
);

84 
addrInfo
.
func_Çme
 = 
ÿÎ”_Çme
;

85 ià(
g_m­_memÜy_addr
.
	`size
(è< 
MAX_LEAK_RECORD_NUM
)

87 
g_m­_memÜy_addr
.
	`š£¹
(
¡d
::
	`make_·œ
(
addrInfo
.
addr
,‡ddrInfo));

92 (è
ÿÎ”
;

93 
	`__fizz_hook_š™
();

94  
±r
;

95 
	}
}

97 
	$__fizz_mempoÞ_de¡roy
()

99 
	`__fizz_hook_»¡Üe
();

101 #ià
defšed
 
__PRIND_LOG


102 
LogH—dInfo
 
h—d_šfo
;

103 
h—d_šfo
.
Ëak_sum
 = 
g_m­_memÜy_addr
.
	`size
();

104 
LogHªdË
::
	`g‘_š¡ªû
().
	`log_h—d_šfo
(
h—d_šfo
);

106 
¡d
::
¡ršg
 
	`lše
("--------------------");

107 
¡d
::
m­
<*, 
AddrInfo
>::
™”©Ü
 
™”
 = 
g_m­_memÜy_addr
.
	`begš
();

108 ; 
™”
 !ð
g_m­_memÜy_addr
.
	`’d
(); ++iter)

110 
LogHªdË
::
	`g‘_š¡ªû
().
	`log_´št
(
lše
);

112 
¡d
::
veùÜ
<¡d::
¡ršg
>::
™”©Ü
 
subI‹r
 = 
™”
->
£cÚd
.
vec_backŒaû
.
	`begš
();

113 ; 
subI‹r
 !ð
™”
->
£cÚd
.
vec_backŒaû
.
	`’d
(); ++ subIter)

115 
¡d
::
¡ršg
 
	`Ëak_šfo
(*
subI‹r
);

116 
LogHªdË
::
	`g‘_š¡ªû
().
	`log_debug
(
Ëak_šfo
);

121 
	}
}

123 
	$__fizz_mempoÞ_š™
()

125 
	`__fizz_hook_back
();

126 
	`__fizz_hook_š™
();

127 
	`©ex™
(
__fizz_mempoÞ_de¡roy
);

130 
	}
}

141 
Ý”©Ü
 
	$d–‘e
(* 
p
)

143 
	`ä“
(
p
);

144 
	}
}

146 
Ý”©Ü
 
	gd–‘e
[](* 
	gp
)

148 
ä“
(
p
);

	@mempool.h

2 #iâdeà
_FIZZ_MEMPOOL_H


3 
	#_FIZZ_MEMPOOL_H


	)

5 
__fizz_mempoÞ_š™
();

7 (* 
__m®loc_š™Ÿlize_hook
è(èð
__fizz_mempoÞ_š™
;

	@memutil.cpp

2 
	~<veùÜ
>

3 
	~<¡ršg
>

6 cÚ¡ 
size_t
 
	gMAX_TRACE_FUNC_NAME_LEN
 = 1000;

7 cÚ¡ 
size_t
 
	gCALLER_FUNC_INDEX
 = 3;

9 
g‘_ÿÎ”_func
(
¡d
::
veùÜ
<¡d::
¡ršg
>& 
vec_backŒaû
, std::¡ršg& 
ÿÎ”_Çme
)

13 * 
Œaû_func_buf
[
MAX_TRACE_FUNC_NAME_LEN
] = {0};

14 
size_t
 
	gŒaû_func_num
 = 0;

15 
	gŒaû_func_num
 = 
backŒaû
(
Œaû_func_buf
, 
MAX_TRACE_FUNC_NAME_LEN
);

17 ** 
	gsymbÞ_li¡
;

18 
	gsymbÞ_li¡
 = 
backŒaû_symbÞs
(
Œaû_func_buf
, 
Œaû_func_num
);

20 ià(
	gŒaû_func_num
 > 
	gCALLER_FUNC_INDEX
)

22 
	gÿÎ”_Çme
.
assign
(
symbÞ_li¡
[
CALLER_FUNC_INDEX
]);

25 
	gvec_backŒaû
.
þ—r
();

26 
size_t
 
	gi
 = 0; i < 
	gŒaû_func_num
; ++i)

28 
	g¡d
::
¡ršg
 
func_Çme
(
symbÞ_li¡
[
i
]);

29 
	gvec_backŒaû
.
push_back
(
func_Çme
);

33 
ä“
(
symbÞ_li¡
);

	@
1
.
0
4
48
loghandle.cpp
mempool.cpp
mempool.h
memutil.cpp
